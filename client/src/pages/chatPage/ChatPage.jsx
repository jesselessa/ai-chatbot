import { useRef, useState, useEffect, Fragment } from "react";
import "./chatPage.css";
import { useParams } from "react-router-dom";
import { useQuery, useQueryClient, useMutation } from "@tanstack/react-query";
import { IKImage } from "imagekitio-react";
import Markdown from "react-markdown";
import model from "../../lib/gemini.js";

// Components
import PromptForm from "../../components/promptForm/PromptForm.jsx";
import Loader from "../../components/loader/Loader.jsx";

const ChatPage = () => {
  const [question, setQuestion] = useState("");
  const [answer, setAnswer] = useState("");
  const [img, setImg] = useState({
    isLoading: false,
    error: "",
    dbData: {}, // IK uploaded image data
    aiData: {}, // Data generated by AI from image
  });

  const chatEndRef = useRef(null);

  const { chatId } = useParams();
  const queryClient = useQueryClient();

  // Fetch chat data
  const fetchChatData = async (chatId) => {
    try {
      const res = await fetch(
        `${import.meta.env.VITE_API_URL}/api/chats/${chatId}`,
        { credentials: "include" }
      );
      if (!res.ok)
        throw new Error(`Failed to fetch chat data: ${res.statusText}`);
      return res.json();
    } catch (err) {
      console.error("Error in fetchChatData:", err.message);
      throw err;
    }
  };

  const {
    isPending,
    error,
    data: chatData,
  } = useQuery({
    queryKey: ["chat", chatId],
    queryFn: () => fetchChatData(chatId),
  });

  // Automatically scroll to the bottom when new content is added
  useEffect(() => {
    if (chatEndRef.current) {
      console.log("ChatEndRef.current", chatEndRef.current);
      chatEndRef.current.scrollIntoView({ behavior: "smooth" });
    }
  }, [chatData?.history]);

  // Update chat data
  const updateChat = async (question, answer, img) => {
    try {
      const res = await fetch(
        `${import.meta.env.VITE_API_URL}/api/chats/${chatId}`,
        {
          method: "PUT",
          credentials: "include",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            question: question.length ? question : undefined,
            answer,
            img: img.dbData?.url || undefined,
          }),
        }
      );
      if (!res.ok) throw new Error(`Failed to update chat: ${res.statusText}`);
      return res.json();
    } catch (err) {
      console.error("Error in updateChat:", err.message);
      throw err;
    }
  };

  const updateMutation = useMutation({
    mutationFn: ({ question, answer, img }) =>
      updateChat(question, answer, img),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["chat", chatId] });

      // Reset states
      setQuestion("");
      setAnswer("");
      setImg({
        isLoading: false,
        error: "",
        dbData: {},
        aiData: {},
      });
    },
    onError: (err) => {
      console.error("Error updating chat:", err.message);
    },
  });

  // Configure chat history
  const chat = model.startChat({
    history:
      chatData?.history?.map(({ role, parts, img }) => ({
        role,
        parts: [{ text: parts[0].text }],
        ...(img && { img }),
      })) || [], // Fallback to an empty array if chatData.history is undefined
    generationConfig: {},
  });

  // Generate AI response
  const generateResponse = async (prompt) => {
    try {
      const result = await chat.sendMessageStream(
        Object.keys(img.aiData).length ? [img.aiData, prompt] : [prompt]
      );

      let accumulatedText = "";
      for await (const chunk of result.stream) {
        accumulatedText += chunk.text();
        setAnswer(accumulatedText);
      }

      updateMutation.mutate({
        question: prompt,
        answer: accumulatedText,
        img: img || undefined,
      });
    } catch (error) {
      if (error.message.includes("SAFETY")) {
        setAnswer(
          "I'm sorry, I can't answer this request. Try another question."
        );
      } else {
        console.error("Error generating content:", error);
        setAnswer("An error occurred. Please try again.");
      }
    }
  };

  const handleSubmit = async (form) => {
    const text = form.text.value.trim();
    if (!text) return;

    setQuestion(text);
    await generateResponse(text);
  };

  return (
    <div className="chatPage">
      <div className="chat">
        {isPending ? (
          <Loader />
        ) : error ? (
          <p>Something went wrong&nbsp;! Please, try again later.</p>
        ) : (
          chatData?.history?.map((message, index) => (
            <Fragment key={index}>
              {message.img && (
                <IKImage
                  urlEndpoint={import.meta.env.VITE_IMAGE_KIT_ENDPOINT}
                  src={message.img}
                  height="300"
                  width="400"
                  transformation={[{ height: 300, width: 400 }]}
                  loading="lazy"
                  // During process of lazy loading, show a loer quality image
                  lqip={{ active: true, quality: 20 }}
                />
              )}

              <div
                className={message.role === "user" ? "message user" : "message"}
              >
                <Markdown>{message.parts[0].text}</Markdown>
              </div>
            </Fragment>
          ))
        )}

        {/* Auto-scroll anchor */}
        <div ref={chatEndRef} />
      </div>
      <PromptForm
        question={question}
        setQuestion={setQuestion}
        setImg={setImg}
        onSubmit={handleSubmit}
      />
    </div>
  );
};

export default ChatPage;
